# ARM-processor

A simple implementation of an ARM-based processor.

## ARM-processor Architecture

The overall architecture of ARM processor simplified:

![ARM-processor Architecture](./img/arm_processor_architecture.png)

## Condition codes

ConditionCheck module receives the condition bits (cond) from the input instruction and checks the condition with the help of the Status Register.

The conditions for the condition to be met are listed in Table.

![Table A3-1 Condition codes](./img/Table_A3-1_Condition_codes.png)

## ARM-processor Instructions

The processor designed and implemented in this project is a simplified ARM processor with 12 main instructions. This processor is capable of performing mathematical operations (ADD, ADC, SUB, SBC), logic operations (AND, ORR, EOR), comparison operations (CMP, TST), read and write operations in memory (LD, ST), has the jump operation (B). The list of operations and their details are given in Table of the CPU Command Set. The NOP command is not implemented as a command.

![Table 2 CPU Instructions](./img/Table_2_CPU_Instructions.png)

## ALU Instructions

The execution stage will include the ALU and the calculation of the jump command address. The ALU has two data inputs, data output, and a four-bit input generated by the Control Unit, determining the ALU operation. This control input is specified in Table.

### ALU Instructions Table

| Instruction | ALU Command |        Operation        |
|:-----------:|:-----------:|:-----------------------:|
|     MOV     |     0001    |       result = in2      |
|     MVN     |     1001    |      result = ~in2      |
|     ADD     |     0010    |    result = in1 + in2   |
|     ADC     |     0011    |  result = in1 + in2 + C |
|     SUB     |     0100    |    result = in1 - in2   |
|     SBC     |     0101    | result = in1 - in2 â€“ ~C |
|     AND     |     0110    |    result = in1 & in2   |
|     ORR     |     0111    |   result = in1 \| in2   |
|     EOR     |     1000    |    result = in1 ^ in2   |
|     CMP     |     0100    |    result = in1 - in2   |
|     TST     |     0110    |    result = in1 & in2   |
|     LDR     |     0010    |    result = in1 + in2   |
|     STR     |     0010    |    result = in1 + in2   |
|      B      |     XXXX    |                         |

## Shift

- Types of shifts
  - [32 bit immediate](#32-bit-immediate-shift)
  - [Immediate shifts](#immediate-shift)
  - [Register shift](#register-shift)

### 32 bit immediate shift

In this case, the value of the immediate bit is equal to one. The 9-bit 8_immed number is placed in a 32-bit container, then rotated twice as much as the value of rotate_imm.

#### 32 bit immediate shift instructions  

| 31:28 | 27 | 26 | 25 |  24:21 | 20 | 19:16 | 15:12 |    11:8    |   7:0   |
|:-----:|:--:|:--:|:--:|:------:|:--:|:-----:|:-----:|:----------:|:-------:|
|  Cond |  0 |  0 |  1 | opcode |  S |   Rn  |   Rd  | rotate_imm | immed_8 |

### Immediate shift

In this case, the immediate bit and the fourth bit of the instruction are also equal to zero. The second operand is read from the register. The read number is then shifted by the value of shift_imm based on shift mode. Shift modes are listed in the table below.

#### Immediate shift instruction  

| 31:28 | 27 | 26 | 25 |  24:21 | 20 | 19:16 | 15:12 |    11:7   |  6:5  | 4 | 3:0 |
|:-----:|:--:|:--:|:--:|:------:|:--:|:-----:|:-----:|:---------:|:-----:|---|-----|
|  Cond |  0 |  0 |  0 | opcode |  S |   Rn  |   Rd  | shift_imm | shift | 0 | Rm  |

#### Shift mode in immediate shift instruction

| Shift mode |       Description      | Value |
|:----------:|:----------------------:|:-----:|
|     LSL    |   Logical shift left   |   00  |
|     LSR    |   Logical shift right  |   01  |
|     ASR    | Arithmetic shift right |   10  |
|     ROR    |      Rotate right      |   11  |

### Register shift

In this case, the immediate bit is equal to zero, and the second operand is read from the register. The read number is then shifted to the Rs register value based on the shift mode. This type of shift has not been implemented in the processor.

#### Register shift instruction

| 31:28 | 27 | 26 | 25 |  24:21 | 20 | 19:16 | 15:12 |    11:7   |  6:5  | 4 | 3:0 |
|:-----:|:--:|:--:|:--:|:------:|:--:|:-----:|:-----:|:---------:|:-----:|---|-----|
|  Cond |  0 |  0 |  0 | opcode |  S |   Rn  |   Rd  | shift_imm | shift | 0 | Rm  |
